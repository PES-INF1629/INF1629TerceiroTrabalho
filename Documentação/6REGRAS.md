# As [6 Regras](https://pes2006.wordpress.com/2006/03/15/disciplina/) do Engenheiro de Software
## e como foram aplicadas no nosso trabalho
--------------------------------------------
## Regra 1 - Identificação:
O prórpio GitHub foi nossa principal ferramenta para esta regra, visto que através de commits temos a visibilidade dos arquivos aderidos ao projeto, de suas diferentes versões e quais modificações foram sofridas. Commits também identificam seus respectivos autores e dados mais específicos como as datas em que ocorreram e a divisão entre o quanto foi acrescentado e retirado tanto do projeto contendo nossa documentação do trabalho como o repositório onde se encontra o código da aplicação que alteramos. Em relação ao código, também fizemos o uso da ferramenta de branches onde inicialmente criamos algumas branches que buscavam tratar de necessidades específicas da aplicação (como a branch **view** que visava atualizar as componentes ligadas à interface com o usuário) como forma de dividir a implementação em tarefas e evitar conflitos entre mudanças feitas por integrantes numa mesma ramificação.

## Regra 2 - Verificação e Validação:
Essa regra só foi implementada de forma bem básica, onde fizemos mais a verificação do conteúdo das estruturas através de prints no console da respectiva máquina do testador (pelo Terminal ou CMD) ou pelo console do container do **sidekiq** através do Kitematic (ferramenta do Docker para gerenciar e executar containers). Mais para as etapas finais, fizemos o uso direto da aplicação fazendo diversas queries e verificando se o conteúdo dentro de cada corpus era o mesmo ao fazer o mesmo tipo de requisição tanto pelo site do GitHub como pela sua API. No caso, tudo foi feito e testado ao executar a aplicação localmente, sem portar ela em um servidor online que é um dos requisitos pedidos pela cliente.

## Regra 3 - Intervalo Mágico:
A aplicação já fazia uso da regra pela forma principal em que sua arquitetura é modularizada pelo modelo **MVC**. Temos a divisão da funcionalidade principal da aplicação em 3 componentes, onde cada uma desempenha um papel único. Em **\views**, temos as classes que lidam com a interface de comunicação do usuário, repassando as informações do que ele deseja obter para as outras componentes e destas obtendo o resultado que apresenta a quem requisitou o serviço. Em **\controllers**, temos quem recebe as informações mandadas pelo usuário e que ativa as componentes que irão de fato prestar o serviço requisitado. Em **\models**, temos as classes que exercem a execução dos serviços e processam os dados que serão apresentados em um corpus. Essas 3 componentes fazem uso de outras bibliotecas auxiliares como **Mongoid** em **issues_set.rb** para armazenar os corpus de resultados dentro de um banco e **Typhoeus** em **client.rb** para fazer as requisições à API, onde cada biblioteca só é usada pela respectiva classe que precisa do seu serviço para atender ao resultado final esperado pelo usuário.

## Regra 4 - Não invente nomes:
A regra está sendo empregada mais fielmente na pasta **\app** que contém quase todas as modificações que fizemos na aplicação. A versão original já empregava a regra na maioria de suas variáveis, classes e métodos. Nos preocupamos mais em aplicar em casos quando criamos novos métodos e quando se faziam menções ao objetivo anterior da aplicação (busca de READMEs). Para casos mais específicos, como **issues_controller.rb**, tivemos que mexer nas configurações do Rails (framework usado pela aplicação) pois atulizar diretamente o nome desses arquivos dava problemas ao executar a aplicação.

Não nos preocupamos em verificar as outras partes do aplicação, como conteúdo da pasta **\config** pois não precisamos alterar para o funcionamento principal e porque alguns diretórios, como **\app\controllers\concerns**, e alguns arquivos, como os **.keep** altamente presentes em mais de um local da aplicação, são criados por default pelo Rails, por exemplo.

## Regra 5 - Desenho Limpo:
Satisfazemos a regra representando a aplicação em 3 modelos de arquitetura. **Class Diagram.jpg** representa a aplicação em um Modelo de Classes, onde damos foco em quais as principais classes e seus respectivos métodos, representando que classe usa qual. Em **Component Diagram.jpg** montamos um Diagrama de Componentes onde o foco são as conexões de serviçoes prestados entre componentes onde mostramos os diretórios em cada as classes se encontram. O arquivo **Arquitetura_MVC.png** já seria uma representação bem simples da aplicação no que seria a arquitetura do MVC, onde é mostrado que classes/componentes desempenham os papéis de Controller, Model e View (fica o aviso que esse modelo não representa como é a divisão exata dos arquivos nos diretórios da aplicação, apenas mostra dentro dos 3 papéis do MVC quem se encaixa mais em qual pela sua funcionalidade). Ademais dessas classes, no arquivo **recuperacao_desenho.md** também registramos nosso entendimento inicial de como a aplicação é estruturada entre seus componentes e ferramentas auxiliares que usa, através de explicações dadas por um dos desenvolvedores da aplicação original.

## Regra 6 - Livro Diário:
Empregamos no arquivo **DIARIO.md** onde separamos por data algumas das tarefas principais feitas para o trabalho. Usamos também como espaço para explicar algumas descobertas e explicações que interessam para o entendimento da aplicação. Nos arquivos presentes em **Documentação/Atas** também registramos as reuniões do grupo e com a cliente, documentando discussões em relação ao que foi feito em diferentes etapas do trabalho e estabelecendo algumas metas para futuras reuniões (como o que mais desenvolver e correções a serem feitas). Fizemos uso do campo de **issues** neste repositório para registrar os requisitos que o software teria que satisfazer pelas necessidades da cliente e por estes estabelecemos no arquivo **RASTRO.md** um mapeamento desses requisitos com os símbolos gerados no modelo Léxico que fizemos no **C&L**. Usamos diversos comentários por este repositório para discutir e registrar ideias e necessidades entre os integrantes e a cliente.
